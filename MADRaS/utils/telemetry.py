"""
Utilities for plotting variables on the approximate maps generated by MADRaS/agents/generic/mapping_agent.py
"""

import numpy as np
import pickle as pkl
import matplotlib.pyplot as plt
import os
import MADRaS.utils.data.track_details as td

MAPDIR = "/home/anirban/Projects/MADRaS_revisited/MADRaS_tmp/MADRaS/utils/data/maps"


class MapPlotter(object):
    def __init__(self, track_name, outdir='/tmp', subsampling_factor=1, visualise=False):
        self.track_name = track_name
        self.track_len = td.track_lengths[self.track_name]
        self.visualise = visualise
        self.outdir = outdir
        self.subsampling_factor = subsampling_factor
        try:
            with open(os.path.join(MAPDIR, self.track_name+'.pkl'), 'rb') as f:
                self.track_map = pkl.load(f)
        except:
            raise ValueError("Map not available for {} in {}".format(self.track_name, MAPDIR))
        for vertex in self.track_map:
            vertex.append([0])
        # Now self.track_map is a list of vertices, each of which is a list
        # [distRaced, coordinates, value_to_plot]
        if self.subsampling_factor > 1:
            self.subsample_map()

    def subsample_map(self):
        self.track_map = self.track_map[::self.subsampling_factor]

    @property
    def all_distRaced(self):
        return np.asarray([x[0] for x in self.track_map])

    def add_value_to_map(self, value, distRaced):
        position_indicator = self.all_distRaced <= distRaced
        end_point_idx = min(sum(position_indicator), len(self.track_map)-1)
        # import pdb; pdb.set_trace()
        self.track_map[end_point_idx][2].append(value)

    def plot_full_map_as_outline(self):
        x_coordinates = ([x[1][0] for x in self.track_map])
        y_coordinates = ([x[1][1] for x in self.track_map])
        plt.plot(x_coordinates, y_coordinates, color='black', alpha=0.2)

    def get_colour(self, normalized_value):
        """
        Used instructions from here: https://stackoverflow.com/questions/8389636/
        creating-over-20-unique-legend-colors-using-matplotlib/8391452#8391452
        """
        # color_range = np.asarray([0, 0.25, 0.5, 0.75, 1.0])
        # colors = ['blue', 'green', 'orange', 'red']
        # idx = min(sum(color_range < normalized_value), 4)
        # return colors[idx-1]

        cm = plt.get_cmap('gist_rainbow')
        return cm(normalized_value)

    def plot_stats(self, plot_file_name, plot_title, min_val, max_val):
        for x in self.track_map:
            x[2] = np.mean(x[2])
        plt.figure()
        plt.title(plot_title)
        self.plot_full_map_as_outline()
        for i in range(1, len(self.track_map)):
            start_point = self.track_map[i-1][1]
            end_point = self.track_map[i][1]
            value = self.track_map[i][2]
            normalized_value = (value - min_val) / (max_val - min_val)
            plt.plot([start_point[0], end_point[0]], [start_point[1], end_point[1]],
                     color=self.get_colour(normalized_value))
        plt.show()
        plt.savefig(os.path.join(self.outdir, plot_file_name))

    def place_landmarks(self, interval=100.0):
        plt.figure()
        plt.title("Landmarks every {} m.".format(interval))
        self.plot_full_map_as_outline()
        d = 0
        while d < self.track_len:
            landmark = self.get_coordinates_from_dist(d)[0]
            if d == 0:
                plt.scatter(landmark[0], landmark[1], marker="s", c='b')
            else:
                plt.scatter(landmark[0], landmark[1], marker="o", c='r')
            d += interval
        # plt.show()
        plt.savefig(os.path.join(self.outdir, "landmarks_on_{}@{}m.png".format(self.track_name, interval)))

    def color_between_landmarks(self, start_dist, end_dist):
        plt.figure()
        plt.title("ROI: {} m to {} m".format(start_dist, end_dist))
        self.plot_full_map_as_outline()
        coordinates_to_color = []
        for vertex in self.track_map:
            if vertex[0] < start_dist or vertex[0] > end_dist:
                continue
            coordinates_to_color.append(vertex[1])
        x_coordinates = [c[0] for c in coordinates_to_color]
        y_coordinates = [c[1] for c in coordinates_to_color]
        plt.plot(x_coordinates, y_coordinates, c="r")
        plt.show()

    def plot_value_on_map(self, variable_values, plot_file_name, plot_title, min_val=None, max_val=None):
        """Plots variable_values on map with color codes.
           variable_values must be a list/generator of tuples of the form (distFromStart, value).

           TODO(santara): Add a colorbar describing the mapping between variable_values and color.
        """
        # if len(variable_values) < 2:
        #     raise ValueError("Not enough entries in list variable_values: {}. Minimum 2.".format(variable_values))
        all_values = [x[1] for x in variable_values]
        max_val = max(all_values) if not max_val else max_val
        min_val = min(all_values) if not min_val else min_val
        plt.figure()
        plt.title(plot_title)
        self.plot_full_map_as_outline()
        for entry in variable_values:
            start_point, end_point = self.get_coordinates_from_dist(entry[0])
            # print(start_point, end_point)
            value = entry[1]
            normalized_value = (value - min_val) / (max_val - min_val)
            plt.plot([start_point[0], end_point[0]], [start_point[1], end_point[1]],
                     color=self.get_colour(normalized_value),
                    #  alpha=normalized_value
                     )
        plt.savefig(os.path.join(self.outdir, plot_file_name))

    def plot_value(self, variable_values, distance_range, smoothen=False, smoothing_window_size=3):
        """
        Plots the values of a variable within a given distance range on the track. This is especially meant
        for visualizing observation and action variables of an agent.

        Args:
            variable_values: list/generator of tuples of the form (distFromStart, value).
            distance_range:  tuple of the form (start_distance, end_distance); gives the range of distances
                             to be considered for plotting the variable_values.
            smoothen:        bool; whether to low pass filter the variable_values before plotting. Currently
                             only simple moving average filter is implemented.
            smoothing_window_size: int; if smoothen is True, what the smoothing window size should be.
        """
        start_dist_range, end_dist_range = distance_range
        values_to_plot = [x[1] for x in variable_values if x[0]>=start_dist_range and x[0]<=end_dist_range]
        if smoothen:
            values_to_plot = np.convolve(values_to_plot,
                                         (1.0/smoothing_window_size) * np.ones(smoothing_window_size),
                                         'same')
        distances = [x[0] for x in variable_values if x[0]>=start_dist_range and x[0]<=end_dist_range]
        plt.plot(distances, values_to_plot)

    def get_coordinates_from_dist(self, element):
        all_distances = np.asarray([x[0] for x in self.track_map])
        position_indicator = all_distances <= element
        end_point_idx = sum(position_indicator)
        if end_point_idx == 0:
            raise ValueError("Distance from start larger than track length")
        start_point_idx = end_point_idx - 1
        return self.track_map[start_point_idx][1], self.track_map[end_point_idx][1]


class RolloutStats(object):
    def __init__(self, track_name, traj_path, outdir, subsampling_factor):
        self.track_name = track_name
        self.plotter = MapPlotter(track_name, outdir, subsampling_factor)
        self.traj_path = traj_path
        with open(self.traj_path, 'rb') as f:
            self.traj_data = pkl.load(f)
        self.traj_data = self.traj_data[-1]
        self.distRaced_data = [x[5]['distRaced'] for x in self.traj_data]

    def plot_obs_in_fig(self, distance_range, smoothen=False, smoothing_window_size=3):
        plt.figure()
        track_data = np.asarray([x[0][1:20] for x in self.traj_data])
        acceleration_data = [x[1][1] for x in self.traj_data]
        data_to_plot = [(x, y) for x,y in zip(self.distRaced_data, acceleration_data)]
        plt.subplot(22, 1, 1)
        plt.title("Acceleration")
        self.plotter.plot_value(data_to_plot, distance_range, smoothen, smoothing_window_size)
        brake_data = [x[1][2] for x in self.traj_data]
        data_to_plot = [(x, y) for x,y in zip(self.distRaced_data, brake_data)]
        plt.subplot(22, 1, 2)
        plt.title("Brake")
        self.plotter.plot_value(data_to_plot, distance_range, smoothen, smoothing_window_size)
        steer_data = [x[1][0] for x in self.traj_data]
        data_to_plot = [(x, y) for x,y in zip(self.distRaced_data, steer_data)]
        plt.subplot(22, 1, 3)
        plt.title("Steer")
        self.plotter.plot_value(data_to_plot, distance_range, smoothen, smoothing_window_size)
        for i in range(19):
            data_to_plot = [(x, y) for x,y in zip(self.distRaced_data, track_data[:, i].tolist())]
            plt.subplot(22, 1, i+4)
            self.plotter.plot_value(data_to_plot, distance_range, False, smoothing_window_size)
        plt.show()

    def plot_actions_in_fig(self, distance_range, smoothen=False, smoothing_window_size=3):
        plt.figure()
        acceleration_data = [x[1][1] for x in self.traj_data]
        data_to_plot = [(x, y) for x,y in zip(self.distRaced_data, acceleration_data)]
        plt.subplot(2, 1, 1)
        plt.title("Acceleration")
        self.plotter.plot_value(data_to_plot, distance_range, smoothen, smoothing_window_size)
        brake_data = [x[1][2] for x in self.traj_data]
        data_to_plot = [(x, y) for x,y in zip(self.distRaced_data, brake_data)]
        plt.subplot(2, 1, 2)
        plt.title("Brake")
        self.plotter.plot_value(data_to_plot, distance_range, smoothen, smoothing_window_size)
        plt.show()

    def plot_angle(self):
        self.angle_data = [x[0][0] for x in self.traj_data]
        data_to_plot = [(x, y) for x,y in zip(self.distRaced_data, self.angle_data)]
        self.plotter.plot_value_on_map(data_to_plot, 'angle.png', 'angle', -1, 1)

    def plot_speed(self):
        self.speedX_data = [x[0][-3] for x in self.traj_data]
        self.speedY_data = [x[0][-2] for x in self.traj_data]
        speed_data = [np.sqrt(x**2+y**2) for x,y in zip(self.speedX_data, self.speedY_data)]
        data_to_plot = [(x, y) for x,y in zip(self.distRaced_data, speed_data)]
        self.plotter.plot_value_on_map(data_to_plot, 'speed.png', 'speed', 0, 1.5)

    def plot_acceleration(self):
        self.accel_data = [x[1][1] for x in self.traj_data]
        data_to_plot = [(x, y) for x,y in zip(self.distRaced_data, self.accel_data)]
        self.plotter.plot_value_on_map(data_to_plot, 'acceleration.png', 'acceleration', -1, 1)

    def plot_brake(self):
        self.brake_data = [x[1][2] for x in self.traj_data]
        data_to_plot = [(x, y) for x,y in zip(self.distRaced_data, self.brake_data)]
        self.plotter.plot_value_on_map(data_to_plot, 'brake.png', 'brake', -1, 1)

    def plot_steer(self):
        self.steer_data = [x[1][0] for x in self.traj_data]
        data_to_plot = [(x, y) for x,y in zip(self.distRaced_data, self.steer_data)]
        self.plotter.plot_value_on_map(data_to_plot, 'steer.png', 'steer', -1, 1)

    def plot_reward(self):
        self.reward_data = [x[3] for x in self.traj_data]
        data_to_plot = [(x, y) for x,y in zip(self.distRaced_data, self.reward_data)]
        self.plotter.plot_value_on_map(data_to_plot, 'reward.png', 'reward')


class RolloutStats2(object):
    def __init__(self, track_name, traj_path, outdir, subsampling_factor):
        self.track_name = track_name
        self.plotter = MapPlotter(track_name, outdir, subsampling_factor)
        self.traj_path = traj_path
        with open(self.traj_path, 'rb') as f:
            self.traj_data = pkl.load(f)

    def plot_angle(self):
        for traj in self.traj_data:
            for x in traj:
                self.plotter.add_value_to_map(x[0][0], x[5]['distRaced'])
        self.plotter.plot_stats('angle.png', 'angle', -1, 1)

    def plot_speed(self):
        for traj in self.traj_data:
            for x in traj:
                speedX = x[0][-3]
                speedY = x[0][-2]
                speed = np.sqrt(speedX**2 + speedY**2)
                self.plotter.add_value_to_map(speed, x[5]['distRaced'])
        self.plotter.plot_stats('speed.png', 'speed', -1, 1.5)


if __name__=='__main__':
    # stat_machine = RolloutStats2(
    #     'alpine-1',
    #     '/home/anirban/Projects/MADRaS_revisited/MADRaS_tmp/MADRaS/experiments/experiment_6/eval_trajs_2.pkl',
    #     '/home/anirban/Projects/MADRaS_revisited/MADRaS_tmp/MADRaS/scripts/alpine_telemetry',
    #     subsampling_factor=100
    # )
    # stat_machine.plot_speed()

    # plotter = MapPlotter('alpine-1', '/home/anirban/Projects/MADRaS_revisited/MADRaS_tmp/MADRaS/results/mapping', 100)
    # plotter.place_landmarks()
    # plotter.color_between_landmarks(700, 900)

    stat_machine = RolloutStats(
        # 'alpine-1',
        # 'aalborg',
        'e-track-4',
        # 'corkscrew',
        # '/home/anirban/Projects/MADRaS_revisited/MADRaS_tmp/MADRaS/experiments/experiment_6/eval_trajs_2.pkl',
        # '/home/anirban/Projects/MADRaS_revisited/MADRaS_tmp/MADRaS/experiments/experiment_13/final_results/eval_trajs_1041_car1-stock1_alpine-1.pkl',
        # '/home/anirban/Projects/MADRaS_revisited/MADRaS_tmp/MADRaS/experiments/temp/eval_trajs_701_car1-stock1_corkscrew.pkl',
        '/home/anirban/Projects/MADRaS_revisited/MADRaS_tmp/MADRaS/experiments/temp/eval_trajs_701_car1-stock1_e-track-4.pkl',
        '/home/anirban/Projects/MADRaS_revisited/MADRaS_tmp/MADRaS/scripts/alpine_telemetry',
        subsampling_factor=100
    )
    stat_machine.plot_obs_in_fig(distance_range=(0, 5), smoothen=True, smoothing_window_size=13)
    # stat_machine.plot_actions_in_fig(distance_range=(100, 200), smoothen=True, smoothing_window_size=57)  